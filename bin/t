#!/usr/bin/env bash

# A command line todo utility
#
# t is inspired by Steve Losh's todo app by the same name (https://stevelosh.com/projects/t/).
# 
# I made this because wanted:
#
#   - nice, big checkboxes;
#   - to see completed tasks;
#   - tasks always printed after every command;
#   - identify tasks by their text (partial match);
#   - a pure bash solution.
#

USAGE=$(cat <<'EOF'
t             List all todo lists
t -x "item"   Check off the task containing "item"
t -X "item"   Uncheck the task containing "item"
t -d "item"   Delete task containing "item"
t -p          Purge completed tasks
t -t          Print uncompleted tasks only
EOF
)

if [ -z T_TODO_DIR ]; then
  TODO_DIR="${T_TODO_DIR}"
else
  TODO_DIR="${HOME}"
fi

TODO_FILE="${TODO_DIR}/.todo.txt"

PRINT_TASKS=1

touch "${TODO_FILE}"

while getopts 'x:X:d:hpt' opt; do
  case "$opt" in
    x)
      arg="${OPTARG}"
      sed -i'.bak' -e "/${arg}/ s/\[ \]/[*]/" "${TODO_FILE}"
      ;;

    X)
      arg="${OPTARG}"
      sed -i'.bak' -e "/${arg}/ s/\[\*\]/[ ]/" "${TODO_FILE}"
      ;;

    d)
      arg="${OPTARG}"
      sed -i'.bak' "/${arg}/d" "${TODO_FILE}"
      ;;

    p)
      sed -i'.bak' "/\[\*\]/d" "${TODO_FILE}"
      ;;

    t)
      cat "${TODO_FILE}" | grep -e '^\[ \]'
      ;;

    h)
      echo "${USAGE}"
      PRINT_TASKS=0
      ;;
  esac
done

if [ $OPTIND -eq 1 ]; then
  [ ${#@} -gt 0 ] && echo "[ ] $@" >> "${TODO_FILE}"
  [ "${PRINT_TASKS}" -eq 1 ] && cat "${TODO_FILE}"
fi

[ -f "${TODO_FILE}.bak" ] && rm "${TODO_FILE}.bak"
