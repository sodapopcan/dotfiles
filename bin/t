#!/usr/bin/env bash

# A command line todo utility
#
# Inspired by Steve Losh's todo app by the same name (https://stevelosh.com/projects/t/).
# 
# I made this because I wanted:
#
#   - nice, big checkboxes;
#   - to see completed tasks;
#   - tasks always printed after every command;
#   - identify tasks by their text (partial match);
#   - a pure bash implementation.
#
set -euo pipefail

USAGE=$(cat <<'EOF'
t             List all todo lists
t Some item   Add task called "Some item"
t -t          Print uncompleted tasks only
t -T          Print completed tasks only
t -x "item"   Check off the task containing "item"
t -X "item"   Uncheck the task containing "item"
t -d "item"   Delete task containing "item"
t -p          Purge completed tasks
t -e          Opens the todo file in $EDITOR
EOF
)

if [ -z T_TODO_DIR ]; then
  TODO_DIR="${T_TODO_DIR}"
else
  TODO_DIR="${HOME}"
fi

TODO_FILE="${TODO_DIR}/.todo.txt"

touch "${TODO_FILE}"

function complete_task {
  sed -i'.bak' -e "/$1/ s/\[ \]/[x]/" "${TODO_FILE}"
}

function uncomplete_task {
  sed -i'.bak' -e "/$1/ s/\[\x\]/[ ]/" "${TODO_FILE}"
}

function delete_task {
  sed -i'.bak' "/$1/d" "${TODO_FILE}"
}

function purge_completed_tasks {
  sed -i'.bak' "/\[\x\]/d" "${TODO_FILE}"
}

function edit_todo_file {
  "$EDITOR" "${TODO_FILE}"
}

function print_tasks {
  cat "${TODO_FILE}"
}

function print_uncompleted_tasks {
  cat "${TODO_FILE}" | grep -e '^\[ \]'
}

function print_completed_tasks {
  cat "${TODO_FILE}" | grep -e '^\[x\]'
}

function print_usage {
  echo "${USAGE}"
}

while getopts 'x:X:d:heptT' opt; do
  case "$opt" in
    x)
      complete_task "${OPTARG}"
      print_tasks
      ;;

    X)
      uncomplete_task "${OPTARG}"
      print_tasks
      ;;

    d)
      delete_task "${OPTARG}"
      print_tasks
      ;;

    p)
      purge_completed_tasks
      print_tasks
      ;;

    t)
      print_uncompleted_tasks
      ;;

    T)
      print_completed_tasks
      ;;

    e)
      edit_todo_file
      ;;

    h)
      print_usage
      ;;
  esac
done

# If there are no options
if [ $OPTIND -eq 1 ]; then
  # If there are non-option arguments (ie, a new task)
  if [ ${#@} -gt 0 ]; then
    num_tasks=$(print_tasks | { grep -i -e "^\[.\] $*\$" || true; } | wc -l)
    if [ $num_tasks -eq 0 ]; then
      echo "[ ] $@" >> "${TODO_FILE}"

      print_tasks
    else
      echo "Task already exists"
    fi
  else
    print_tasks
  fi
fi

[ -f "${TODO_FILE}.bak" ] && rm "${TODO_FILE}.bak"

exit 0
